using UnityEditor;
using UnityEngine;
using System.Collections;
using System;

/***
* MeshCreatorInspector
*	modifies the inspector to show controls for the Mesh Creator.
*	this script needs to be in the Editor folder of your project along
*	with the SimpleSurfaceEdge.cs and the Triangulator.cs script.
***/
[CustomEditor(typeof(MeshCreatorData))]
public class MeshCreatorInspector :  Editor {
	
	private MeshCreatorData mcd;
	
	/***
	* OnEnable
	* 	set the MeshCreator when component is added to the object
	***/
	private void OnEnable()
    {
		mcd = target as MeshCreatorData;
		if (mcd == null) {
			Debug.LogError("MeshCreatorInspector::OnEnable(): couldn't find a MeshCreatorData component");
		}
    }
	
	/***
	* OnInspectorGUI
	*	this does the main display of information in the inspector.
	***/
	public override void OnInspectorGUI() {
		EditorGUIUtility.LookLikeInspector();
		//EditorGUIUtility.LookLikeControls();
		
		// TODO: inspector layout should be redesigned so that it's easier to 
		//	 see the texture and material information
		if (mcd != null) {
			EditorGUILayout.LabelField("Mesh Creation Outline", "");
			mcd.outlineTexture = EditorGUILayout.ObjectField("Mesh Outline Texture", mcd.outlineTexture, typeof(Texture2D)) as Texture2D;
			mcd.uvWrapMesh = EditorGUILayout.Toggle("Use UV mapped mesh", mcd.uvWrapMesh);
			if (!mcd.uvWrapMesh) {
				mcd.useEdges = EditorGUILayout.Toggle("Use UV mapped edge", mcd.useEdges);
				if (!mcd.useEdges) {
					mcd.useBackside = EditorGUILayout.Toggle("Use backside plane", mcd.useBackside);
				}
			}
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Material Assignment", "");
			mcd.useAutoGeneratedMaterial = EditorGUILayout.Toggle("Use Generated Material", mcd.useAutoGeneratedMaterial);
			if (!mcd.useAutoGeneratedMaterial) mcd.frontMaterial = EditorGUILayout.ObjectField("Mesh Material", mcd.frontMaterial, typeof(Material)) as Material;
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Physics Material", "");
			mcd.usePhysicMaterial = EditorGUILayout.Toggle("Use Physics Material", mcd.usePhysicMaterial);
			if (mcd.usePhysicMaterial) mcd.physicMaterial = EditorGUILayout.ObjectField("Physical Material", mcd.physicMaterial, typeof(PhysicMaterial)) as PhysicMaterial;
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Size and Placement", "");
			mcd.meshHeight = EditorGUILayout.FloatField("Mesh Height", mcd.meshHeight);
			mcd.meshWidth = EditorGUILayout.FloatField("Mesh Width", mcd.meshWidth);
			mcd.meshDepth = EditorGUILayout.FloatField("Mesh Depth", mcd.meshDepth);
			
			mcd.heightOffset = EditorGUILayout.FloatField("Height Offset", mcd.heightOffset);
			mcd.widthOffset = EditorGUILayout.FloatField("Width Offset", mcd.widthOffset);
			
			EditorGUILayout.Space();
			EditorGUILayout.LabelField("Collider Generation", "");
			mcd.generateCollider = EditorGUILayout.Toggle("Generate Collider", mcd.generateCollider);
			if (mcd.generateCollider) mcd.usePrimitiveCollider = EditorGUILayout.Toggle("Use Primitive Collider", mcd.usePrimitiveCollider);
			if (mcd.usePrimitiveCollider) mcd.smallestBoxArea = EditorGUILayout.FloatField("Smallest Box Area", mcd.smallestBoxArea);
			EditorGUILayout.Space();
			
			if (GUILayout.Button("Update Mesh", GUILayout.MaxWidth(100))) {
				// do some simple parameter checking here so we don't get into trouble
				if (mcd.smallestBoxArea < 2) {
					Debug.LogWarning("Mesh Creator: smallest box area should be larger than 1.");
				}
				else {
					UpdateMesh();
					//Editor.Repaint(); // error when deleting colliders
				}
			}
		}
		else {
			Debug.LogError("MeshCreatorInspector::OnInspectorGUI(): couldn't find a MeshCreatorData component");
		}
		
	}
	
	// this corresponds with the Update Mesh button
    void UpdateMesh () {

			if (mcd == null) {
				Debug.LogError("MeshCreatorInspector Error: selected object does not have a MeshCreatorData component. Select an object with a MeshCreatorData component to update."); // TODO: add instructions on how to fix
				return;
			}
			
			// add a TextureImporter object here to check whether texture is readable
			// set it to readable if necessary
			if (mcd.outlineTexture == null) {
				Debug.LogError("MeshCreatorInspector Error: no texture found. Make sure to have a texture selected before updating mesh.");
				return;
			}
			
			Mesh msh = new Mesh();
			if (mcd.uvWrapMesh) {
				// Set up game object with mesh;
				AssignMesh(ref msh);
			}
			else {
				AssignFlatMesh(ref msh);
			}
			
			MeshRenderer mr = (MeshRenderer) mcd.gameObject.GetComponent("MeshRenderer");
			if (mr == null) {
				Debug.Log("MeshCreator Warning: no mesh renderer found on update object, adding one.");
				mcd.gameObject.AddComponent(typeof(MeshRenderer));
			}
			
			// update the front material via renderer
			if (mcd.useAutoGeneratedMaterial) {
				Material meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
				if (meshmat == null) {
					AssetDatabase.CopyAsset("Assets/Materials/baseMaterial.mat", "Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
					AssetDatabase.ImportAsset("Assets/Materials/"+mcd.outlineTexture.name+".material.mat");
					meshmat = (Material) Resources.LoadAssetAtPath("Assets/Materials/"+mcd.outlineTexture.name+".material.mat", typeof(Material));
					meshmat.name = mcd.outlineTexture.name + ".Material";
					meshmat.mainTexture = mcd.outlineTexture;
					AssetDatabase.SaveAssets();
				}
				mcd.gameObject.renderer.sharedMaterial = meshmat;
			}
			else {
				mcd.gameObject.renderer.sharedMaterial = mcd.frontMaterial;
			}
			
			MeshFilter mf = (MeshFilter) mcd.gameObject.GetComponent("MeshFilter");
			if (mf == null) {
				Debug.LogWarning("MeshCreator Warning: no mesh filter found on update object, adding one.");
				mf= mcd.gameObject.AddComponent(typeof(MeshFilter)) as MeshFilter;
			}
			DestroyImmediate(mf.sharedMesh);
			mf.sharedMesh = msh;
			
			// generate a mesh collider
			if (mcd.generateCollider && !mcd.usePrimitiveCollider) {
				Collider col = mcd.gameObject.collider;
				if (col == null) {
					mcd.gameObject.AddComponent(typeof(MeshCollider));
				}
				// remove the old compound collider if necessary
				string compoundColliderName = mcd.gameObject.name + "CompoundColliders";
				foreach(Transform child in mcd.gameObject.transform) {
					if (child.name == compoundColliderName) {
						DestroyImmediate(child.gameObject);
					}
				}
				
				// stash the rotation value, set back to identity, then switch back later
				Quaternion oldRotation = mcd.gameObject.transform.rotation;
				mcd.gameObject.transform.rotation = Quaternion.identity;
				
				// stash the scale value, set back to one, then switch back later
				Vector3 oldScale = mcd.gameObject.transform.localScale;
				mcd.gameObject.transform.localScale = Vector3.one;
				
				MeshCollider mcol = mcd.gameObject.GetComponent("MeshCollider") as MeshCollider;
				if (mcol == null) {
					Debug.LogWarning("MeshCreator Warning: found a non-Mesh collider on object to update. If you really want a new collider generated, remove the old one and update the object with MeshCreator again.");
				}
				else {
					mcol.sharedMesh = msh;
				}
				if (mcd.usePhysicMaterial) {
					mcol.material = mcd.physicMaterial;
				}
				mcd.gameObject.transform.rotation = oldRotation;
				mcd.gameObject.transform.localScale = oldScale;
			}
			else if (mcd.generateCollider && mcd.usePrimitiveCollider) {
				// remove the old collider if necessary
				Collider col = mcd.gameObject.collider;
				if (col != null) {
					//DestroyImmediate(col); // using destroy here causes a editor error after the script runs
					col = null;
				}
				
				// all compound colliders are stored in a gameObject 
				string compoundColliderName = mcd.gameObject.name + "CompoundColliders";
				GameObject go = new GameObject();
				// find old compound colliders and remove
				foreach (Transform child in mcd.gameObject.transform) {
					if (child.name == compoundColliderName) {
						DestroyImmediate(go);
						go = child.gameObject;
						ArrayList removeChildren = new ArrayList();
						foreach (Transform childchild in child) {
							removeChildren.Add(childchild);
						}
						foreach (Transform childchild in removeChildren) {
							DestroyImmediate(childchild.gameObject);
						}
					}
				}
				
				// stash the rotation value, set back to identity, then switch back later
				Quaternion oldRotation = mcd.gameObject.transform.rotation;
				mcd.gameObject.transform.rotation = Quaternion.identity;
				
				// stash the scale value, set back to one, then switch back later
				Vector3 oldScale = mcd.gameObject.transform.localScale;
				mcd.gameObject.transform.localScale = Vector3.one;
				
				go.name = compoundColliderName;
				go.transform.parent = mcd.gameObject.transform;
				go.transform.localPosition = Vector3.zero;
				go.transform.rotation = Quaternion.identity;
				ArrayList boxColliderCoordinates = GetBoxColliderCoordinates();
				int count = 0;
				int imageHeight = mcd.outlineTexture.height;
				int imageWidth = mcd.outlineTexture.width;
				foreach (Vector4 bc in boxColliderCoordinates) {
					count++;
					GameObject colgo = new GameObject();
					colgo.name = compoundColliderName+"."+count;
					colgo.transform.parent = go.transform;
					colgo.transform.localPosition = Vector3.zero;
					BoxCollider bxcol = colgo.AddComponent(typeof(BoxCollider)) as BoxCollider;
					
					float vertX = 1.0f - (bc.x/imageWidth) ; // get X point and normalize
					float vertY = bc.y/imageHeight ; // get Y point and normalize
					float vert2X = 1.0f - (bc.z/imageWidth);
					float vert2Y = bc.w/imageHeight;
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					
					vert2X = (vert2X * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vert2Y = (vert2Y * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vert2X = vert2X + mcd.widthOffset;
					vert2Y = vert2Y + mcd.heightOffset;
					
					bxcol.center = new Vector3(vertX - ((vertX-vert2X)/2.0f), vertY - ((vertY-vert2Y)/2.0f), 0.0f);
					bxcol.size = new Vector3(Math.Abs(vertX-vert2X), Math.Abs(vertY-vert2Y), mcd.meshDepth);
					if (mcd.usePhysicMaterial) {
						bxcol.material = mcd.physicMaterial;
					}
				}
				mcd.gameObject.transform.rotation = oldRotation;
				mcd.gameObject.transform.localScale = oldScale;
			}
    }  
	
	// TODO: this should be moved to another script, kinda funky here
	ArrayList GetBoxColliderCoordinates() {
		ArrayList boxCoordinates = new ArrayList();
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);

		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// possibly do some size checking
		// TODO: check for a square power of two
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
		}
		
		// copy the pixels so they can be modified
		Color[] pix = new Color[pixels.Length];
		for (int i = 0; i < pixels.Length; i++) {
			Color pixel = pixels[i];
			pix[i] = new Color(pixel.r, pixel.g, pixel.b, pixel.a);
		}
		
		Vector4 boxCoord = GetLargestBox(ref pix, imageWidth, imageHeight);
		while ((Math.Abs(boxCoord.x-boxCoord.z) * Math.Abs(boxCoord.y-boxCoord.w) ) >= mcd.smallestBoxArea) {
			boxCoordinates.Add(boxCoord);
			boxCoord = GetLargestBox(ref pix, imageWidth, imageHeight);
		}
		return boxCoordinates;
	}
	
	/***
	* GetLargestBox
	*	takes pixel data ref and finds largest rectangular area of solid opaque pixels.
	*	pixels are then deleted inside that rectangular area.
	* returns Vector4 of opposite corner coordinates, or Vector4(-1.0) if no area found.
	*
	* TODO: this is really slow. incrementally checking pixel box areas is not efficient. 
	*	maybe try checking max first and then half that amount, then half, and so on.
	*    check this: http://stackoverflow.com/questions/1726632/dynamic-programming-largest-square-block
	***/
	Vector4 GetLargestBox(ref Color[] pixs, int imageWidth, int imageHeight) {
		Vector4 boxCoords = new Vector4(-1.0f, -1.0f, -1.0f, -1.0f);
		int area = 1; // smallest possible area
		
		// determine largest box area
		for (int x = 0; x < imageWidth; x++) {
			for (int y = 0; y < imageHeight; y++) {
				// get the first pixel
				float pixelAlpha = pixs[x + (imageWidth * y)].a;
				
				// only continue if the current pixel is opaque
				if (pixelAlpha != 1.0) continue;
				
				// determine largest opaque square
				for (int i = 1; i < imageWidth - x; i++) {
					for (int j = 1; j < imageHeight - y; j++) {
						if ( (i*j) > area) {
							if (IsOpaque(ref pixs, x, y, i, j, imageWidth, imageHeight)) {
								if ((i*j) > area) {
									boxCoords = new Vector4(x,y,x+i,y+j);
									area = i*j;
								}
							}
							else {
								break;
							}
						}
					}
				}
			}
		}
		
		// remove inside pixels from the box area
		if (boxCoords.x != -1.0f) {
			for (int i = (int)boxCoords.x + 1; i < (int)boxCoords.z; i++) {
				for (int j = (int)boxCoords.y + 1; j < (int)boxCoords.w; j++) {
					pixs[i + (j *imageWidth)].a = 0.0f;
				}
			}
			// delete all pixels if this is width 1 or height 1
			if ( ((int)Math.Abs(boxCoords.x-boxCoords.z) == 1) || ((int)Math.Abs(boxCoords.y-boxCoords.w) == 1) ){
				for (int i = (int)boxCoords.x; i <= (int)boxCoords.z; i++) {
					for (int j = (int)boxCoords.y; j <= (int)boxCoords.w; j++) {
						pixs[i + (j *imageWidth)].a = 0.0f;
					}
				}
			}
		}
		return boxCoords;
	}
	
	/***
	* IsOpaque
	*	determines if all all pixels in a box of the given parameters are opaque.
	***/
	bool IsOpaque(ref Color[] pixs, int startx, int starty, int width, int height, int imageWidth, int imageHeight) {
		if ((startx + width) > imageWidth) return false;
		if ((starty + height) > imageHeight) return false;
		for (int x = startx; x <= startx+width; x++) {
			for (int y = starty; y <= starty + height; y++) {
				float alpha = pixs[x+(imageWidth *y)].a;
				if (alpha != 1.0) return false;
			}
		}
		return true;
	}
	
	/*
	*	GetMesh() does calculation of a uv mapped mesh from the raster image.
	*/ 
	public void AssignMesh(ref Mesh msh) {
			string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
			TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
			textureImporter.isReadable = true;
			AssetDatabase.ImportAsset(path);
			
			//Debug.Log("found texture " + outlineTexture.width + "," + outlineTexture.height);
			Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			//Debug.Log("total pixel count " + pixels.Length);
			
			// possibly do some size checking
			int imageHeight = mcd.outlineTexture.height;
			int imageWidth = mcd.outlineTexture.width;
			if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
				Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
				Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
			}
			
			// make a surface object to create and store data from image
			MC_SimpleSurfaceEdge mcs = new MC_SimpleSurfaceEdge(pixels,  imageWidth, imageHeight);
			
			// Create the mesh
			//Mesh msh = new Mesh();
			
			if (!mcs.ContainsIslands()) {
				// need a list of ordered 2d points
				Vector2 [] vertices2D = mcs.GetOutsideEdgeVertices();
        
				// Use the triangulator to get indices for creating triangles
				Triangulator tr = new Triangulator(vertices2D);
				int[] indices = tr.Triangulate(); // these will be reversed for the back side
				Vector2[] uvs = new Vector2[vertices2D.Length * 4];
				// Create the Vector3 vertices
				Vector3[] vertices = new Vector3[vertices2D.Length * 4];
				//Vector3[] verticesBack = new Vector3[vertices2D.Length];
			
				float halfDepth = mcd.meshDepth/2.0f;
				for (int i=0; i<vertices2D.Length; i++) {
					float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
					float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					vertices[i] = new Vector3(vertX, vertY, -halfDepth);
					vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
					vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
					vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
					uvs[i] = mcs.GetUVForIndex(i);
					uvs[i+vertices2D.Length] = uvs[i];
					uvs[i+(vertices2D.Length*2)] = uvs[i];
					uvs[i+(vertices2D.Length*3)] = uvs[i];
				}
			
				// make the back side triangle indices
				// double the indices for front and back, 6 times the number of edges on front
				int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
				// copy over the front and back index data
				for (int i = 0; i < indices.Length; i++) {
					allIndices[i] = indices[i]; // front side uses normal indices returned from the algorithm
					allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length; // backside reverses the order
				}
			
				// create the side triangle indices
				// for each edge, create a new set of two triangles
				// edges are just two points from the original set
				for (int i = 0; i < vertices2D.Length - 1; i++) {
					allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1;
					allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i ;
					allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i ;
					allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length;
				}
			
				// wrap around for the last face
				allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0;
				allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1;
		
			
				msh.vertices = vertices;
				msh.triangles = allIndices;
				msh.uv = uvs;
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
			else { // there be islands here, so treat mesh creation slightly differently
				ArrayList allVertexLoops = mcs.GetAllEdgeVertices();
				
				ArrayList completeVertices = new ArrayList();
				ArrayList completeIndices = new ArrayList();
				ArrayList completeUVs = new ArrayList();
				int verticesOffset = 0;
				int indicesOffset = 0;
				int uvOffset = 0;
				int loopCount = 0;
				foreach (Vector2[] vertices2D in allVertexLoops) {
					// TODO: this needs to check if the current list is inside another shape
					// Use the triangulator to get indices for creating triangles
					Triangulator tr = new Triangulator(vertices2D);
					int[] indices = tr.Triangulate(); // these will be reversed for the back side
					Vector2[] uvs = new Vector2[vertices2D.Length * 4];
					// Create the Vector3 vertices
					Vector3[] vertices = new Vector3[vertices2D.Length * 4];
			
					float halfDepth = mcd.meshDepth/2.0f;
					for (int i=0; i<vertices2D.Length; i++) {
						float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
						float vertY = vertices2D[i].y/imageHeight ; // get Y point and normalize
						vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
						vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
						vertX = vertX + mcd.widthOffset;
						vertY = vertY + mcd.heightOffset;
						vertices[i] = new Vector3(vertX, vertY, -halfDepth);
						vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
						vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
						vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
						uvs[i] = mcs.GetUVForIndex(loopCount, i);
						uvs[i+vertices2D.Length] = uvs[i];
						uvs[i+(vertices2D.Length*2)] = uvs[i];
						uvs[i+(vertices2D.Length*3)] = uvs[i];
					}
			
					// make the back side triangle indices
					// double the indices for front and back, 6 times the number of edges on front
					int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
					// copy over the front and back index data
					for (int i = 0; i < indices.Length; i++) {
						allIndices[i] = indices[i] +verticesOffset; // front side uses normal indices returned from the algorithm
						allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length + verticesOffset; // backside reverses the order
					}
			
					// create the side triangle indices
					// for each edge, create a new set of two triangles
					// edges are just two points from the original set
					for (int i = 0; i < vertices2D.Length - 1; i++) {
						allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1 + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length+ verticesOffset;
					}
			
					// wrap around for the last face
					allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0+ verticesOffset;
					allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1+ verticesOffset;
					
					foreach(Vector3 v in vertices) {
						completeVertices.Add(v);
					}
					foreach(Vector2 v in uvs) {
						completeUVs.Add(v);
					}
					foreach(int i in allIndices) {
						completeIndices.Add(i);
					}
					
					verticesOffset += vertices.Length;
					uvOffset += uvs.Length;
					indicesOffset += allIndices.Length;
					loopCount++;
				}
				msh.vertices = (Vector3[]) completeVertices.ToArray(typeof(Vector3));
				msh.triangles = (int[]) completeIndices.ToArray(typeof(int));
				msh.uv = (Vector2[]) completeUVs.ToArray(typeof(Vector2));
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
	}
	
	/*
	*	GetMesh() does calculation of a uv mapped mesh from the raster image.
	*/ 
	public void AssignFlatMesh(ref Mesh msh) {
		// get the outline texture
		string path = AssetDatabase.GetAssetPath(mcd.outlineTexture);
		TextureImporter textureImporter = AssetImporter.GetAtPath(path) as TextureImporter;
		textureImporter.isReadable = true;
		AssetDatabase.ImportAsset(path);
			
		Color[] pixels = mcd.outlineTexture.GetPixels();	// get the pixels to build the mesh from
			
		// do some size checking
		int imageHeight = mcd.outlineTexture.height;
		int imageWidth = mcd.outlineTexture.width;
		
		if ( ((float)imageWidth)/((float)imageHeight) != mcd.meshWidth/mcd.meshHeight) {
			Debug.LogWarning("Mesh Creator Inspector Warning: selected meshWidth and meshHeight is not the same proportion as source image width and height. Results may be distorted.");
			Debug.LogWarning("    You may want to resize your image to be square, it can be easier that way.");
		}
		
		if (
		// make a surface object to create and store data from image
		MC_SimpleSurfaceEdge mcs = new MC_SimpleSurfaceEdge(pixels,  imageWidth, imageHeight);
			
			if (!mcs.ContainsIslands()) {
				// need a list of ordered 2d points
				Vector2 [] vertices2D = mcs.GetOutsideEdgeVertices();
        
				// Use the triangulator to get indices for creating triangles
				Triangulator tr = new Triangulator(vertices2D);
				int[] indices = tr.Triangulate(); // these will be reversed for the back side
				Vector2[] uvs = new Vector2[vertices2D.Length * 4];
				// Create the Vector3 vertices
				Vector3[] vertices = new Vector3[vertices2D.Length * 4];
				//Vector3[] verticesBack = new Vector3[vertices2D.Length];
			
				float halfDepth = mcd.meshDepth/2.0f;
				for (int i=0; i<vertices2D.Length; i++) {
					float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
					float vertY = vertices2D[i].y/imageHeight; // get Y point and normalize
					vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
					vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
					vertX = vertX + mcd.widthOffset;
					vertY = vertY + mcd.heightOffset;
					vertices[i] = new Vector3(vertX, vertY, -halfDepth);
					vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
					vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
					vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
					uvs[i] = mcs.GetUVForIndex(i);
					uvs[i+vertices2D.Length] = uvs[i];
					uvs[i+(vertices2D.Length*2)] = uvs[i];
					uvs[i+(vertices2D.Length*3)] = uvs[i];
				}
			
				// make the back side triangle indices
				// double the indices for front and back, 6 times the number of edges on front
				int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
				// copy over the front and back index data
				for (int i = 0; i < indices.Length; i++) {
					allIndices[i] = indices[i]; // front side uses normal indices returned from the algorithm
					allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length; // backside reverses the order
				}
			
				// create the side triangle indices
				// for each edge, create a new set of two triangles
				// edges are just two points from the original set
				for (int i = 0; i < vertices2D.Length - 1; i++) {
					allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1;
					allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i ;
					allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length;
					allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i ;
					allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length;
				}
			
				// wrap around for the last face
				allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0;
				allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length;
				allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1;
				allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1;
		
			
				msh.vertices = vertices;
				msh.triangles = allIndices;
				msh.uv = uvs;
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
			else { // there be islands here, so treat mesh creation slightly differently
				ArrayList allVertexLoops = mcs.GetAllEdgeVertices();
				
				ArrayList completeVertices = new ArrayList();
				ArrayList completeIndices = new ArrayList();
				ArrayList completeUVs = new ArrayList();
				int verticesOffset = 0;
				int indicesOffset = 0;
				int uvOffset = 0;
				int loopCount = 0;
				foreach (Vector2[] vertices2D in allVertexLoops) {
					// TODO: this needs to check if the current list is inside another shape
					// Use the triangulator to get indices for creating triangles
					Triangulator tr = new Triangulator(vertices2D);
					int[] indices = tr.Triangulate(); // these will be reversed for the back side
					Vector2[] uvs = new Vector2[vertices2D.Length * 4];
					// Create the Vector3 vertices
					Vector3[] vertices = new Vector3[vertices2D.Length * 4];
			
					float halfDepth = mcd.meshDepth/2.0f;
					for (int i=0; i<vertices2D.Length; i++) {
						float vertX = 1.0f - (vertices2D[i].x/imageWidth) ; // get X point and normalize
						float vertY = vertices2D[i].y/imageHeight ; // get Y point and normalize
						vertX = (vertX * mcd.meshWidth) - (mcd.meshWidth / 2.0f);  // scale X and position centered
						vertY = (vertY * mcd.meshHeight) - (mcd.meshHeight / 2.0f);
						vertX = vertX + mcd.widthOffset;
						vertY = vertY + mcd.heightOffset;
						vertices[i] = new Vector3(vertX, vertY, -halfDepth);
						vertices[i + vertices2D.Length] = new Vector3(vertX, vertY, halfDepth);
						vertices[i+(vertices2D.Length*2)] = new Vector3(vertX, vertY, -halfDepth); // vertex for side
						vertices[i +(vertices2D.Length*3)] = new Vector3(vertX, vertY, halfDepth);
						uvs[i] = mcs.GetUVForIndex(loopCount, i);
						uvs[i+vertices2D.Length] = uvs[i];
						uvs[i+(vertices2D.Length*2)] = uvs[i];
						uvs[i+(vertices2D.Length*3)] = uvs[i];
					}
			
					// make the back side triangle indices
					// double the indices for front and back, 6 times the number of edges on front
					int[] allIndices = new int[(indices.Length*2) + ( (vertices2D.Length ) * 6)];
			
					// copy over the front and back index data
					for (int i = 0; i < indices.Length; i++) {
						allIndices[i] = indices[i] +verticesOffset; // front side uses normal indices returned from the algorithm
						allIndices[(indices.Length*2) - i -1] = indices[i] + vertices2D.Length + verticesOffset; // backside reverses the order
					}
			
					// create the side triangle indices
					// for each edge, create a new set of two triangles
					// edges are just two points from the original set
					for (int i = 0; i < vertices2D.Length - 1; i++) {
						allIndices[(indices.Length*2) + (6 * i)] = (vertices2D.Length *2) + i + 1 + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 1] = (vertices2D.Length *2) +i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 2] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 3] = (vertices2D.Length *2) + i + 1 + vertices2D.Length+ verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 4] = (vertices2D.Length *2) + i + verticesOffset;
						allIndices[(indices.Length*2) + (6 * i) + 5] = (vertices2D.Length *2) + i + vertices2D.Length+ verticesOffset;
					}
			
					// wrap around for the last face
					allIndices[allIndices.Length-6] = (vertices2D.Length *2) + 0+ verticesOffset;
					allIndices[allIndices.Length-5] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-4] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-3] = (vertices2D.Length *2) +vertices2D.Length+ verticesOffset;
					allIndices[allIndices.Length-2] = (vertices2D.Length *2) +vertices2D.Length-1+ verticesOffset;
					allIndices[allIndices.Length-1] = (vertices2D.Length *2) + (vertices2D.Length*2) - 1+ verticesOffset;
					
					foreach(Vector3 v in vertices) {
						completeVertices.Add(v);
					}
					foreach(Vector2 v in uvs) {
						completeUVs.Add(v);
					}
					foreach(int i in allIndices) {
						completeIndices.Add(i);
					}
					
					verticesOffset += vertices.Length;
					uvOffset += uvs.Length;
					indicesOffset += allIndices.Length;
					loopCount++;
				}
				msh.vertices = (Vector3[]) completeVertices.ToArray(typeof(Vector3));
				msh.triangles = (int[]) completeIndices.ToArray(typeof(int));
				msh.uv = (Vector2[]) completeUVs.ToArray(typeof(Vector2));
				msh.RecalculateNormals();
				msh.RecalculateBounds();
				msh.name = mcd.outlineTexture.name + ".mesh";
			}
	}
	
}

